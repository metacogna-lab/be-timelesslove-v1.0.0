# Supabase Storage Upload Guide

## Overview

This guide explains how the React UI should coordinate with the backend for direct Supabase Storage uploads. The frontend uploads files directly to Supabase Storage (bypassing the backend for large files), then registers the media references with the backend.

## Storage Bucket Configuration

### Bucket Setup

**Bucket Name**: `memories`  
**Public Access**: No (private bucket with signed URLs)  
**File Size Limit**: 50MB per file  
**Allowed MIME Types**:
- Images: `image/jpeg`, `image/png`, `image/gif`, `image/webp`
- Videos: `video/mp4`, `video/webm`

### Bucket Creation

Create the bucket in Supabase Dashboard:
1. Go to Storage â†’ Buckets
2. Create new bucket named `memories`
3. Set to **Private** (not public)
4. Configure policies (see below)

### Storage Policies

**Policy**: `Users can upload to their family's folder`
```sql
CREATE POLICY "Users can upload to family folder"
  ON storage.objects FOR INSERT
  WITH CHECK (
    bucket_id = 'memories'
    AND (storage.foldername(name))[1] IN (
      SELECT family_unit_id::text
      FROM user_profiles
      WHERE id = auth.uid()
    )
  );
```

**Policy**: `Users can view files in their family's folder`
```sql
CREATE POLICY "Users can view family files"
  ON storage.objects FOR SELECT
  USING (
    bucket_id = 'memories'
    AND (storage.foldername(name))[1] IN (
      SELECT family_unit_id::text
      FROM user_profiles
      WHERE id = auth.uid()
    )
  );
```

## Upload Flow

### Step 1: Request Upload URL

**Endpoint**: `POST /api/v1/storage/upload-url`

**Request**:
```json
{
  "memory_id": "770e8400-e29b-41d4-a716-446655440002",
  "file_name": "photo.jpg",
  "mime_type": "image/jpeg"
}
```

**Response**:
```json
{
  "upload_url": "https://...supabase.co/storage/v1/object/sign/memories/...",
  "storage_path": "660e8400-e29b-41d4-a716-446655440001/770e8400-e29b-41d4-a716-446655440002/photo.jpg",
  "expires_in": 300
}
```

### Step 2: Upload File Directly to Supabase Storage

Use the `upload_url` to upload the file directly:

```javascript
// React example
const formData = new FormData();
formData.append('file', file);

const response = await fetch(uploadUrlResponse.upload_url, {
  method: 'POST',
  body: formData,
  headers: {
    'Content-Type': file.type
  }
});

if (!response.ok) {
  throw new Error('Upload failed');
}
```

**Note**: The signed URL includes all necessary authentication. No additional headers needed.

### Step 3: Register Media with Backend

**Endpoint**: `POST /api/v1/memories` (for new memory) or `POST /api/v1/memories/{memory_id}/media` (for existing memory)

**Request**:
```json
{
  "title": "Family Vacation",
  "description": "Our trip to the beach",
  "status": "published",
  "media": [
    {
      "storage_path": "660e8400-e29b-41d4-a716-446655440001/770e8400-e29b-41d4-a716-446655440002/photo.jpg",
      "file_name": "photo.jpg",
      "mime_type": "image/jpeg",
      "file_size": 2048576
    }
  ]
}
```

**Response**: Memory with media records (processing status: "pending")

## Path Structure

Files are stored with the following structure:

```
memories/
  {family_unit_id}/
    {memory_id}/
      {media_id}.{ext}          # Original file
      {media_id}_thumb.jpg      # Thumbnail (generated by backend)
```

**Example**:
```
memories/
  660e8400-e29b-41d4-a716-446655440001/
    770e8400-e29b-41d4-a716-446655440002/
      880e8400-e29b-41d4-a716-446655440003.jpg
      880e8400-e29b-41d4-a716-446655440003_thumb.jpg
```

## Access Flow

### Get Signed Access URL

**Endpoint**: `GET /api/v1/storage/access-url?storage_path={path}`

**Response**:
```json
{
  "access_url": "https://...supabase.co/storage/v1/object/sign/memories/...",
  "expires_in": 3600
}
```

**Usage**: Use the `access_url` to display or download media. URLs expire after 1 hour (configurable).

### Get Media URL by ID

**Endpoint**: `GET /api/v1/storage/media/{media_id}/url`

**Response**: Same as above, but uses media ID instead of storage path.

## Complete Example Flow

```javascript
// 1. User selects files
const files = [...fileInput.files];

// 2. Create memory (or use existing memory_id)
const memoryResponse = await fetch('/api/v1/memories', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    title: 'New Memory',
    status: 'published'
  })
});
const memory = await memoryResponse.json();

// 3. For each file, get upload URL and upload
const mediaRefs = [];
for (const file of files) {
  // Get upload URL
  const uploadUrlResponse = await fetch('/api/v1/storage/upload-url', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      memory_id: memory.id,
      file_name: file.name,
      mime_type: file.type
    })
  });
  const { upload_url, storage_path } = await uploadUrlResponse.json();
  
  // Upload file directly to Supabase Storage
  const formData = new FormData();
  formData.append('file', file);
  
  await fetch(upload_url, {
    method: 'POST',
    body: formData
  });
  
  // Store media reference
  mediaRefs.push({
    storage_path,
    file_name: file.name,
    mime_type: file.type,
    file_size: file.size
  });
}

// 4. Register media with backend
await fetch(`/api/v1/memories/${memory.id}/media`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(mediaRefs[0])  // Add one at a time, or batch endpoint
});

// 5. Backend processes media in background (thumbnails, etc.)
// Check processing_status in media record to see when complete
```

## Error Handling

### Upload URL Expiration

Upload URLs expire after 5 minutes. If upload takes longer:
1. Request a new upload URL
2. Retry the upload

### File Size Limits

- **Per File**: 50MB maximum
- **Per Memory**: 200MB total

If exceeded, backend will return `400 Bad Request` with error message.

### Invalid File Types

Only allowed MIME types are accepted. Backend validates before generating upload URL.

## Security Considerations

1. **Signed URLs**: All uploads and access use time-limited signed URLs
2. **Family Scoping**: Users can only upload to their family's folder
3. **Path Validation**: Backend validates storage paths to prevent path traversal
4. **File Type Validation**: Only whitelisted MIME types allowed
5. **Size Limits**: Enforced both client-side and server-side

## Best Practices

1. **Batch Uploads**: Request all upload URLs first, then upload files in parallel
2. **Progress Tracking**: Show upload progress for large files
3. **Error Recovery**: Handle upload failures gracefully, allow retry
4. **URL Caching**: Cache access URLs until expiration (1 hour)
5. **Thumbnail Usage**: Use thumbnails for gallery views, full images for detail views

## Processing Status

Media processing happens asynchronously. Check `processing_status` field:

- `pending`: Uploaded, processing not started
- `processing`: Currently being processed
- `completed`: Thumbnail generated, ready to use
- `failed`: Processing failed (check `metadata.error`)

Poll the memory endpoint to check when processing is complete, or use WebSocket notifications (future enhancement).

